

.. _sphx_glr_dimer_lattice_plot_landau_2ndfit.py:


Landau Theory of the Mott transition
====================================

Perform a fit of the order parameter, linked to double occupation to
match a Landau theory formulation in correspondence to Kotliar, G.,
Lange, E., & Rozenberg, M. J. (2000). Landau Theory of the Finite
Temperature Mott Transition. Phys. Rev. Lett., 84(22),
5180â€“5183. http://dx.doi.org/10.1103/PhysRevLett.84.5180




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /dimer_lattice/images/sphx_glr_plot_landau_2ndfit_001.png
            :scale: 47

    *

      .. image:: /dimer_lattice/images/sphx_glr_plot_landau_2ndfit_002.png
            :scale: 47

    *

      .. image:: /dimer_lattice/images/sphx_glr_plot_landau_2ndfit_003.png
            :scale: 47


.. rst-class:: sphx-glr-script-out

 Out::

    [67 61 62 61 59 57 55 53 51 49 47 45 44 42 41 39 38 37 37 37 38 38 38 39 39
     39 39 39 39 40 40 40 40 40 40 40 40 41 41 41 41 41 41 41 41 41 41 42 42 42
     42 42 42 42 42 42 42 42 43 43 43 43 43 43 43 43 43 43 44 44 44 44 44 44 44
     44 44 44 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 44
     44 44 43 43 42 42 41 40 39 38 37 36 35 33 32 30 28 27 25 23 21]
    [68 64 66 67 66 65 64 62 60 58 56 54 52 50 49 47 46 44 43 42 42 43 43 44 44
     45 45 46 46 47 47 48 48 49 49 49 50 50 51 51 51 52 52 53 53 53 54 54 54 55
     55 55 56 56 56 57 57 57 58 58 58 59 59 59 59 60 60 60 60 61 61 61 61 61 62
     62 62 62 62 62 62 62 62 62 61 61 61 61 60 60 59 59 58 57 57 56 55 54 53 52
     51 49 48 47 45 44 42 41 39 38 36 34 33 31 29 28 26 24 22 21 19]
    [67 64 68 70 71 71 71 70 68 67 65 63 61 59 58 56 54 53 51 50 48 47 47 49 49
     50 51 52 53 54 55 56 57 58 60 61 62 63 64 65 66 67 68 70 71 72 73 75 76 77
     78 80 81 82 83 85 86 87 88 89 90 91 92 93 94 95 95 95 96 96 95 95 94 94 93
     92 91 89 88 86 84 83 81 79 77 75 73 71 69 67 65 63 61 59 57 55 53 51 50 48
     46 45 43 41 40 38 37 35 34 32 31 30 28 27 25 24 23 21 20 18 17]
    [ 67  64  68  71  72  73  73  73  72  71  69  68  66  64  63  61  59  58
      56  54  53  51  50  49  51  52  53  54  56  57  58  60  61  62  64  66
      67  69  70  72  74  76  78  80  82  84  86  89  91  94  97  99 102 105
     108 111 113 116 119 122 124 126 127 128 129 129 129 127 126 124 121 118
     115 111 108 104 100  97  93  89  86  83  80  77  74  71  69  66  64  61
      59  57  55  53  51  50  48  46  45  43  42  40  39  37  36  35  33  32
      31  30  28  27  26  25  24  22  21  20  19  17  16]
    [ 65  63  67  70  73  74  75  76  75  75  74  72  71  70  68  67  65  63
      62  60  59  57  56  54  53  52  53  54  55  57  58  60  61  63  65  67
      69  71  73  75  78  80  83  86  89  92  96 100 104 109 114 120 126 132
     139 147 155 164 172 180 187 193 195 195 192 185 177 168 158 148 139 130
     122 114 108 102  96  91  87  83  79  75  72  69  66  63  61  59  57  55
      53  51  49  47  46  44  43  41  40  39  37  36  35  34  33  32  31  29
      28  27  26  25  24  23  22  21  20  19  18  17  15]
    [ 63  61  65  69  72  74  76  77  77  77  77  76  75  74  73  72  71  69
      68  66  65  64  62  61  60  58  57  56  55  55  56  57  59  61  63  65
      66  69  71  73  76  79  82  85  88  92  97 102 107 113 120 129 139 150
     164 182 204 233 270 316 364 387 363 313 262 222 191 168 149 135 123 113
     105  98  92  86  81  77  73  70  67  64  62  59  57  55  53  51  49  48
      46  45  43  42  41  39  38  37  36  35  34  33  32  31  30  29  28  27
      26  25  24  24  23  22  21  20  19  18  17  16  15]
    [ 63  60  65  69  72  74  76  77  78  78  78  78  77  76  75  74  73  71
      70  69  67  66  65  63  62  61  60  58  57  56  55  57  58  60  61  63
      65  67  69  72  74  77  80  83  87  91  95 100 106 112 120 129 140 153
     170 191 222 266 336 454 604 554 393 290 229 191 164 144 129 118 108 100
      93  87  82  78  74  70  67  64  62  59  57  55  53  51  49  48  46  45
      44  42  41  40  39  38  36  35  34  33  33  32  31  30  29  28  27  26
      25  25  24  23  22  21  20  19  19  18  17  16  15]
    [  1.95033299e+06  -6.08793782e+04   5.11670475e+02  -2.43178074e+01
      -1.81934648e-03]
    [ -9.97087857e+03  -1.36764921e+01   1.78298666e+00  -2.98179551e+01
      -9.30447888e-04]
    [  2.13877950e+06  -7.00809692e+04   4.34743341e+02  -1.88771383e+01
      -3.65381945e-03]
    [ -2.11215981e+04  -1.30915898e+01   1.45142139e+00  -2.34644480e+01
      -2.38264567e-03]
    [  2.33857634e+06  -8.43320037e+04   4.89676133e+02  -1.39459228e+01
      -6.62413522e-03]
    [ -6.04367136e+04  -1.25507424e+01   1.10169302e+00  -1.82923408e+01
      -2.44196659e-03]
    [  2.40806136e+06  -9.24510153e+04   5.75339143e+02  -1.17658725e+01
      -8.41332417e-03]
    [ -2.34953915e+04  -7.17145425e+00   1.57511254e+00  -2.68135609e+01
      -6.04394265e-04]
    [  2.42894008e+06  -9.82758422e+04   6.41618809e+02  -9.64445787e+00
      -1.07097747e-02]
    [ -2.69676473e+04  -5.70005695e+00   1.54791233e+00  -2.65166326e+01
       1.48654674e-03]
    [  2.42147180e+06  -1.02918003e+05   7.07348459e+02  -7.65975220e+00
      -1.36974516e-02]
    [ -3.61720516e+04  -4.49311084e+00   1.43443167e+00  -2.45351132e+01
       4.29929438e-03]
    [  2.41735022e+06  -1.07066089e+05   8.13987195e+02  -7.28626236e+00
      -1.39745897e-02]
    [ -4.37983573e+04  -3.97326147e+00   1.37796966e+00  -2.39865798e+01
       9.76745950e-03]




|


.. code-block:: python



    from scipy.optimize import curve_fit
    import numpy as np
    import matplotlib.pyplot as plt
    import dmft.dimer as dimer
    import dmft.common as gf
    import dmft.ipt_imag as ipt


    def loop_u_tp(u_range, tprange, beta, seed='mott gap'):
        tau, w_n = gf.tau_wn_setup(dict(BETA=beta, N_MATSUBARA=256))
        giw_d, giw_o = dimer.gf_met(w_n, 0., 0., 0.5, 0.)
        if seed == 'ins':
            giw_d, giw_o = 1 / (1j * w_n + 4j / w_n), np.zeros_like(w_n) + 0j

        giw_s = []
        sigma_iw = []
        ekin, epot = [], []
        iterations = []
        for u_int, tp in zip(u_range, tprange):
            giw_d, giw_o, loops = dimer.ipt_dmft_loop(
                beta, u_int, tp, giw_d, giw_o, tau, w_n)
            giw_s.append((giw_d, giw_o))
            iterations.append(loops)
            g0iw_d, g0iw_o = dimer.self_consistency(
                1j * w_n, 1j * giw_d.imag, giw_o.real, 0., tp, 0.25)
            siw_d, siw_o = ipt.dimer_sigma(u_int, tp, g0iw_d, g0iw_o, tau, w_n)
            sigma_iw.append((siw_d.copy(), siw_o.copy()))

            ekin.append(dimer.ekin(giw_d, giw_o, w_n, tp, beta))

            epot.append(dimer.epot(giw_d, w_n, beta, u_int **
                                   2 / 4 + tp**2, ekin[-1], u_int))
        print(np.array(iterations))
        # last division in energies because I want per spin epot
        return np.array(giw_s), np.array(sigma_iw), np.array(ekin) / 4, np.array(epot) / 4, w_n


    # calculating multiple regions
    fac = np.arctan(.55 * np.sqrt(3) / .15)
    udelta = np.tan(np.linspace(-fac, fac, 121)) * .15 / np.sqrt(3)
    dudelta = np.diff(udelta)
    data = []
    bet_uc = [(18, 3.312),
              (19, 3.258),
              (20, 3.214),
              (20.5, 3.193),
              (21, 3.17),
              (21.5, 3.1467),
              (21.7, 3.138)]

    for beta, uc in bet_uc:
        urange = udelta + uc + .07
        giw_s, sigma_iw, ekin, epot, w_n = loop_u_tp(
            urange, .3 * np.ones_like(urange), beta, 'met')
        data.append(2 * epot / urange - 0.003)

    plt.figure()
    bc = [b for b, _ in bet_uc]
    d_c = [dc[int(len(udelta) / 2)] for dc in data]
    for dd, dc, (beta, uc) in zip(data, d_c, bet_uc):
        plt.plot(uc + udelta, dd, '+-', label=r'$\beta={}$'.format(beta))

    plt.plot([uc for _, uc in bet_uc], d_c, 'o')

    plt.gca().set_color_cycle(None)
    for dd, (beta, uc) in zip(data, bet_uc):
        chi = np.diff(dd) / dudelta
        plt.plot(uc + udelta[:-1], chi / np.min(chi) * .035, ':')

    plt.title(r'Double occupation')
    plt.ylabel(r'$\langle n_\uparrow n_\downarrow \rangle$')
    plt.xlabel(r'$U/D$')
    plt.legend()
    #plt.savefig("dimer_tp0.3_docc.pdf", transparent=False, bbox_inches='tight', pad_inches=0.05)

    # effective scaling
    plt.figure()


    def fit_cube_lin(d, c, p, y, x, q):
        # / (1 + q * eta)
        return (c * (y * d + x * d**2) ** 3 + p * (y * d + x * d**2)) + q


    plt.figure()
    for dd, dc, (beta, uc) in zip(data, d_c, bet_uc):
        plt.plot(udelta, dd - dc, lw=2)

    plt.gca().set_color_cycle(None)
    bb = [1] * 7  # [30, 30, 35, 42, 45, 48, 50]
    for dd, dc, bound, (beta, uc) in zip(data, d_c, bb, bet_uc):
        rd = dd - dc
        z = np.polyfit(rd[bound:-bound], udelta[bound:-bound], 4)
        print(z)
        popt, pcov = curve_fit(
            fit_cube_lin, rd[bound:-bound], udelta[bound:-bound], p0=[-100, -4, 1, -20, -1e-2])
        print(popt)
        p = fit_cube_lin(rd, *popt)
        plt.plot(p, rd, label=r'$\beta={}$'.format(beta))
        p = np.poly1d(z)(rd)
        #plt.plot(p, rd,":", label=r'$\beta={}$'.format(beta))

    #plt.xlim([-.08, .08])
    #plt.ylim([-.007, .01])

    plt.title(r'Reduced Double occupation fitted to theory')
    plt.ylabel(r'$\eta$')
    plt.xlabel(r'$U-U_c$')
    plt.legend()
    plt.show()

**Total running time of the script:** ( 1 minutes  15.231 seconds)



.. container:: sphx-glr-footer


  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_landau_2ndfit.py <plot_landau_2ndfit.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_landau_2ndfit.ipynb <plot_landau_2ndfit.ipynb>`

.. rst-class:: sphx-glr-signature

    `Generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
